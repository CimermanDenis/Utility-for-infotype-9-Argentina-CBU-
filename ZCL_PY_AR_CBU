CLASS zcl_py_ar_cbu DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC.

  PUBLIC SECTION.
    TYPES: BEGIN OF ty_params,
             pernr TYPE pernr_d,
             begda TYPE begda,
             endda TYPE endda,
             bankl TYPE p0009-bankl,
             cbu   TYPE char22,         "Exactly 22 digits
             subty TYPE p0009-subty,    "Subtype (e.g. '0')
           END OF ty_params.

    TYPES: BEGIN OF ty_result,
             success TYPE abap_bool,
             message TYPE string,
           END OF ty_result.

    CLASS-METHODS preview_bankl " A wrapper because I want to show the derived bankl on selection screen.
      IMPORTING i_subty      TYPE p0009-subty
                i_cbu        TYPE char22
      EXPORTING e_bankl      TYPE p0009-bankl
      RETURNING VALUE(r_msg) TYPE string.

    CLASS-METHODS run
      IMPORTING i_params        TYPE ty_params
      RETURNING VALUE(r_result) TYPE ty_result.

  PRIVATE SECTION.
    CONSTANTS: c_infty     TYPE infty VALUE '0009',
               c_subty_0   TYPE subty VALUE '0',
               c_subty_2   TYPE subty VALUE '2',
               c_min_begda TYPE begda VALUE '18000101',
               c_max_endda TYPE endda VALUE '99991231',
               c_main_bkey TYPE p0009-bankl VALUE '00016',
               c_land1     TYPE p0009-adrs_banks VALUE 'AR',
               c_banks     TYPE p0009-banks VALUE 'AR',  " Argentina
               c_bkont     TYPE p0009-bkont VALUE 'CA',  " control key
               c_zlsch     TYPE p0009-zlsch VALUE 'U',   " Transferencia Bancaria (Citi)
               c_waers     TYPE p0009-waers VALUE 'ARS', " Argentine Peso
               c_cbuln     TYPE i VALUE 22.

    " Derive BANKL from SUBTY/CBU (SUBTY '0' => '00016'; SUBTY '2' => from CBU)
    CLASS-METHODS derive_bankl
      IMPORTING i_subty      TYPE p0009-subty
                i_cbu        TYPE char22
      EXPORTING e_bankl      TYPE p0009-bankl
      RETURNING VALUE(r_msg) TYPE string.

    " Validate BANKL in BNKA (exists in AR and not marked for deletion)
    CLASS-METHODS validate_bankl_bnka
      IMPORTING i_banks      TYPE p0009-banks
                i_bankl      TYPE p0009-bankl
                i_subty      TYPE p0009-subty
      RETURNING VALUE(r_msg) TYPE string.

    CLASS-METHODS validate_inputs
      IMPORTING i_params     TYPE ty_params
      RETURNING VALUE(r_msg) TYPE string.

    CLASS-METHODS get_limits
      IMPORTING i_pernr         TYPE pernr_d
                i_begda         TYPE begda
      EXPORTING e_leaving_begda TYPE begda     "BEGDA (STAT2='0')
                e_accounted_to  TYPE endda     "IT0003-ABRDT
      RETURNING VALUE(r_msg)    TYPE string.

    CLASS-METHODS check_limits
      IMPORTING i_pernr         TYPE pernr_d
                i_begda         TYPE begda
                i_leaving_begda TYPE begda
                i_accounted_to  TYPE endda
      RETURNING VALUE(r_msg)    TYPE string.

    CLASS-METHODS derive_from_cbu
      IMPORTING i_subty      TYPE p0009-subty
                i_cbu        TYPE char22
      EXPORTING e_bkref      TYPE p0009-bkref
                e_bankn      TYPE p0009-bankn
      RETURNING VALUE(r_msg) TYPE string.

    CLASS-METHODS lock_emp
      IMPORTING i_pernr      TYPE pernr_d
      RETURNING VALUE(r_msg) TYPE string.

    CLASS-METHODS unlock_emp
      IMPORTING i_pernr TYPE pernr_d.

    CLASS-METHODS find_overlap_0009
      IMPORTING i_pernr      TYPE pernr_d
                i_begda      TYPE begda
                i_subty      TYPE p0009-subty
      RETURNING VALUE(r_old) TYPE p0009.

    CLASS-METHODS delimit_old_0009
      IMPORTING i_old        TYPE p0009
                i_new_begda  TYPE begda
      RETURNING VALUE(r_msg) TYPE string.

    CLASS-METHODS insert_new_0009
      IMPORTING i_params     TYPE ty_params
                i_land1      TYPE p0009-adrs_banks
                i_bankl      TYPE p0009-bankl
                i_banks      TYPE p0009-banks
                i_bankn      TYPE p0009-bankn
                i_bkont      TYPE p0009-bkont
                i_bkref      TYPE p0009-bkref
                i_zlsch      TYPE p0009-zlsch
                i_waers      TYPE p0009-waers
                i_abrdt      TYPE p0003-abrdt
      RETURNING VALUE(r_msg) TYPE string.

    CLASS-METHODS check_hr_authorizations
      IMPORTING i_pernr      TYPE pernr_d
                i_begda      TYPE begda
                i_endda      TYPE endda
                i_subty      TYPE p0009-subty
      RETURNING VALUE(r_msg) TYPE string.


ENDCLASS.



CLASS zcl_py_ar_cbu IMPLEMENTATION.

  METHOD check_hr_authorizations.
    DATA: lt_p0001 TYPE STANDARD TABLE OF p0001 WITH DEFAULT KEY.

    "Read IT0001 once for the period: for structural authorizations (P_ORGINCON, P_ORGXXCON) we need org. context
    CALL FUNCTION 'HR_READ_INFOTYPE'
      EXPORTING
        pernr     = i_pernr
        infty     = '0001'
        begda     = i_begda
        endda     = i_endda
        tclas     = 'A'
      TABLES
        infty_tab = lt_p0001
      EXCEPTIONS
        OTHERS    = 1.
    " no error handling: empty i0001 is accepted but it cannot happen anyway


    "IT0000 – READ (LEVEL = 'R')
    CALL FUNCTION 'HR_CHECK_AUTHORITY_INFTY'
      EXPORTING
        tclas            = 'A'
        pernr            = i_pernr
        infty            = '0000'
        subty            = space
        begda            = i_begda
        endda            = i_endda
        level            = 'R'
        uname            = sy-uname
      TABLES
        i0001            = lt_p0001
      EXCEPTIONS
        no_authorization = 1
        internal_error   = 2.
    IF sy-subrc <> 0.
      r_msg = |No authorization to READ IT0000 for PERNR { i_pernr }.|.
      RETURN.
    ENDIF.

    "IT0003 – READ
    CALL FUNCTION 'HR_CHECK_AUTHORITY_INFTY'
      EXPORTING
        tclas            = 'A'
        pernr            = i_pernr
        infty            = '0003'
        subty            = space
        begda            = i_begda
        endda            = i_endda
        level            = 'R'
        uname            = sy-uname
      TABLES
        i0001            = lt_p0001
      EXCEPTIONS
        no_authorization = 1
        internal_error   = 2.
    IF sy-subrc <> 0.
      r_msg = |No authorization to READ IT0003 for PERNR { i_pernr }.|.
      RETURN.
    ENDIF.

    "IT0009 – WRITE (maintain)
    CALL FUNCTION 'HR_CHECK_AUTHORITY_INFTY'
      EXPORTING
        tclas            = 'A'
        pernr            = i_pernr
        infty            = '0009'
        subty            = i_subty
        begda            = i_begda
        endda            = i_endda
        level            = 'W'
        uname            = sy-uname
      TABLES
        i0001            = lt_p0001
      EXCEPTIONS
        no_authorization = 1
        internal_error   = 2.
    IF sy-subrc <> 0.
      r_msg = |No authorization to MAINTAIN IT0009/SUBTY { i_subty } for PERNR { i_pernr }.|.
      RETURN.
    ENDIF.

    r_msg = ''.
  ENDMETHOD.


  METHOD check_limits.
    DATA lv_begda_txt TYPE string.
    DATA lv_abrdt_txt TYPE string.

    "Check BEGDA vs IT0003-ABRDT
    IF i_accounted_to IS NOT INITIAL AND i_begda <= i_accounted_to.
      lv_begda_txt = |{ i_begda DATE = USER }|.
      lv_abrdt_txt = |{ i_accounted_to DATE = USER }|.
      r_msg = |Start date { lv_begda_txt } cannot be ≤ accounted to date { lv_abrdt_txt }|.
      RETURN.
    ENDIF.

  ENDMETHOD.


  METHOD delimit_old_0009.
    DATA: ls_old_key   TYPE p0009,
          ls_new_rec   TYPE p0009,
          lv_old_begda TYPE begda,
          lv_old_endda TYPE endda,
          lv_new_end   TYPE endda,
          ls_ret       TYPE bapireturn1.

    "--- 1) Derive new ENDDA (BEGDA of a new record minus 1)
    lv_new_end = i_new_begda - 1.

    "If endda is before begda, there is no delimitation (not applicable for IT 0009 though, constraint class 1)
    IF lv_new_end < i_old-begda.
      r_msg = ''.
      RETURN.
    ENDIF.

    "--- 2) Get ready the correct keys and record
    ls_old_key = i_old.                "former copy with old content
    lv_old_begda = i_old-begda.
    lv_old_endda = i_old-endda.

    ls_new_rec = i_old.                "local copy for new content
    ls_new_rec-endda = lv_new_end.     "changing only end
    ls_new_rec-sprps = space.          "just in case of a lock-flag

    CLEAR ls_ret.
    CALL FUNCTION 'HR_INFOTYPE_OPERATION'
      EXPORTING
        infty         = c_infty
        number        = ls_old_key-pernr
        subtype       = ls_old_key-subty
        validitybegin = lv_old_begda
        validityend   = lv_old_endda
        record        = ls_new_rec        "ENDDA = BEGDA(new)-1
        operation     = 'MOD'
        dialog_mode   = '0'
        nocommit      = 'X'
      IMPORTING
        return        = ls_ret.

    IF ls_ret-type = 'E' OR ls_ret-type = 'A'.
      DATA: lv_old_begda_txt TYPE string,
            lv_old_endda_txt TYPE string,
            lv_new_end_txt   TYPE string.
      lv_old_begda_txt = |{ lv_old_begda DATE = USER }|.
      lv_old_endda_txt = |{ lv_old_endda DATE = USER }|.
      lv_new_end_txt = |{ lv_new_end DATE = USER }|.
      r_msg = |Delimiting failed: { ls_ret-message } Keys: BEGDA={ lv_old_begda_txt }, ENDDA={ lv_old_endda_txt } NewEnd: { lv_new_end_txt }|.
    ELSE.
      r_msg = ''.
    ENDIF.
  ENDMETHOD.


  METHOD derive_bankl.
    CLEAR: e_bankl, r_msg.
    "Subtype rules:
    " - SUBTY '0' => fixed bank key '00 016'
    " - SUBTY '2' => derive from CBU (first 7 digits as bank key)
    CASE i_subty.
      WHEN c_subty_0.
        e_bankl = c_main_bkey.
      WHEN c_subty_2.
        IF strlen( i_cbu ) = c_cbuln.
          e_bankl = i_cbu+0(7).
        ELSE.
          r_msg = 'Cannot derive BANKL: CBU must have 22 digits.'.
        ENDIF.
      WHEN OTHERS.
        "Other subtypes not supported here; no derivation
        r_msg = |Subtype { i_subty } not supported for BANKL derivation.| .
    ENDCASE.
  ENDMETHOD.


  METHOD derive_from_cbu.
    DATA: lv_bkref TYPE p0009-bkref,
          lv_bankn TYPE p0009-bankn.

    CASE i_subty.
      WHEN c_subty_0.
        DATA(lv_first8) = i_cbu+0(8).
        DATA(lv_tail14) = i_cbu+8(14).
        CONCATENATE '0'   lv_first8 INTO lv_bkref.
        CONCATENATE '000' lv_tail14 INTO lv_bankn.
      WHEN c_subty_2.
        DATA(lv_first18)  = i_cbu+0(18).
        DATA(lv_last4)    = i_cbu+18(4).
        lv_bkref = lv_last4.
        lv_bankn = lv_first18.
      WHEN OTHERS.
        r_msg = |Only subtypes 0 and 2 are supported (given: { i_subty })|.
    ENDCASE.

    IF r_msg IS INITIAL.
      e_bkref = lv_bkref.
      e_bankn = lv_bankn.
    ENDIF.
  ENDMETHOD.


  METHOD find_overlap_0009.
    DATA lt_p0009 TYPE STANDARD TABLE OF p0009 WITH EMPTY KEY.

    CALL FUNCTION 'HR_READ_INFOTYPE'
      EXPORTING
        pernr     = i_pernr
        infty     = c_infty
        begda     = c_min_begda
        endda     = c_max_endda
        tclas     = 'A'
      TABLES
        infty_tab = lt_p0009
      EXCEPTIONS
        OTHERS    = 1.

    "Handle FM return code (for ATC SLIN)
    IF sy-subrc <> 0.
      "Read failed (no auth/technical issue) -> no overlap returned
      CLEAR r_old.
      RETURN.
    ENDIF.

    LOOP AT lt_p0009 ASSIGNING FIELD-SYMBOL(<l>)
         WHERE begda <= i_begda
           AND endda >= i_begda
           AND subty = i_subty.
      r_old = <l>.
      EXIT.
    ENDLOOP.
  ENDMETHOD.


  METHOD get_limits.
    DATA: lt0000   TYPE STANDARD TABLE OF p0000 WITH EMPTY KEY,
          lt0003   TYPE STANDARD TABLE OF p0003 WITH EMPTY KEY,
          ls0000   TYPE p0000,
          ls0003   TYPE p0003,
          lv_today TYPE sy-datum.

    CLEAR: e_leaving_begda, e_accounted_to.
    lv_today = sy-datum.

    "---- IT0000: search for termination (STAT2='0'), get its begda
    CALL FUNCTION 'HR_READ_INFOTYPE'
      EXPORTING
        pernr     = i_pernr
        infty     = '0000'
        begda     = c_min_begda
        endda     = c_max_endda
        tclas     = 'A'
      TABLES
        infty_tab = lt0000
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc = 0 AND lt0000 IS NOT INITIAL.
      CLEAR e_leaving_begda.
      DELETE lt0000 WHERE stat2 <> '0'.
      IF lt0000 IS NOT INITIAL.
        SORT lt0000 BY begda DESCENDING.
        READ TABLE lt0000 INTO ls0000 INDEX 1.
        e_leaving_begda = ls0000-begda.   "latest termination BEGDA
      ELSE.
        CLEAR e_leaving_begda.            "no termination found
      ENDIF.
    ENDIF.

    "---- IT0003: get payroll accounted-to
    CALL FUNCTION 'HR_READ_INFOTYPE'
      EXPORTING
        pernr     = i_pernr
        infty     = '0003'
        begda     = c_min_begda
        endda     = c_max_endda
        tclas     = 'A'
      TABLES
        infty_tab = lt0003
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc = 0 AND lt0003 IS NOT INITIAL.
      LOOP AT lt0003 INTO ls0003
           WHERE begda <= lv_today AND endda >= lv_today.
        e_accounted_to = ls0003-abrdt.
        EXIT.
      ENDLOOP.
    ENDIF.

    r_msg = ''.
  ENDMETHOD.


  METHOD insert_new_0009.
    DATA ls_new TYPE p0009.

    CLEAR ls_new.
    ls_new-pernr      = i_params-pernr.
    ls_new-subty      = i_params-subty.
    ls_new-begda      = i_params-begda.
    ls_new-endda      = i_params-endda.
    ls_new-bankl      = i_bankl.
    ls_new-adrs_banks = i_land1.
    ls_new-banks      = i_banks.
    ls_new-bkref      = i_bkref.
    ls_new-bankn      = i_bankn.
    ls_new-bkont      = i_bkont.
    ls_new-zlsch      = i_zlsch.
    ls_new-waers      = i_waers.

    IF i_abrdt IS NOT INITIAL AND i_params-begda <= i_abrdt.
      r_msg =
        |Start date { i_params-begda DATE = USER } cannot be ≤ accounted to date { i_abrdt DATE = USER }|.
      RETURN.
    ENDIF.

    DATA ls_ret_ins TYPE bapireturn1.
    CALL FUNCTION 'HR_INFOTYPE_OPERATION'
      EXPORTING
        infty         = c_infty
        number        = ls_new-pernr
        validitybegin = ls_new-begda
        validityend   = ls_new-endda
        record        = ls_new
        operation     = 'INS'
        dialog_mode   = '0'
        nocommit      = 'X'
      IMPORTING
        return        = ls_ret_ins.

    IF ls_ret_ins-type = 'E' OR ls_ret_ins-type = 'A'.
      r_msg = |Insert failed: { ls_ret_ins-message }|.
    ENDIF.
  ENDMETHOD.


  METHOD lock_emp.
    CALL FUNCTION 'HR_EMPLOYEE_ENQUEUE'
      EXPORTING
        number = i_pernr
      EXCEPTIONS
        OTHERS = 1.
    IF sy-subrc <> 0.
      r_msg = |Failed to lock PERNR { i_pernr }|.
    ENDIF.
  ENDMETHOD.


  METHOD preview_bankl.
    DATA lv_msg TYPE string.
    CLEAR: e_bankl, r_msg.

    "derive
    lv_msg = derive_bankl(
               EXPORTING i_subty = i_subty
                         i_cbu   = i_cbu
               IMPORTING e_bankl = e_bankl ).
    IF lv_msg IS NOT INITIAL.
      r_msg = lv_msg.
      RETURN.
    ENDIF.

    "validate against BNKA for subtype '2' in AR
    lv_msg = validate_bankl_bnka(
               EXPORTING i_banks = c_banks
                         i_bankl = e_bankl
                         i_subty = i_subty ).
    IF lv_msg IS NOT INITIAL.
      r_msg = lv_msg.
      RETURN.
    ENDIF.

    r_msg = ''.
  ENDMETHOD.


  METHOD run.
    DATA: lv_bkref     TYPE p0009-bkref,
          lv_bankn     TYPE p0009-bankn,
          ls_old       TYPE p0009,
          lv_msg       TYPE string,
          lv_leave     TYPE endda,
          lv_abrdt     TYPE endda,
          lv_leave_txt TYPE string,
          lv_abrdt_txt TYPE string,
          lv_begda_txt TYPE string,
          lv_endda_txt TYPE string.

    "1) Validate inputs
    lv_msg = validate_inputs( i_params ).
    IF lv_msg IS NOT INITIAL.
      r_result-success = abap_false.
      r_result-message = lv_msg.
      RETURN.
    ENDIF.

    "2) HR authorizations (R for 0000/0003, W for 0009)
    lv_msg = check_hr_authorizations(
               i_pernr = i_params-pernr
               i_begda = i_params-begda
               i_endda = i_params-endda
               i_subty = i_params-subty ).
    IF lv_msg IS NOT INITIAL.
      r_result-success = abap_false.
      r_result-message = lv_msg.
      RETURN.
    ENDIF.


    "3) Read limits from IT0000/IT0003
    lv_msg = get_limits(
               EXPORTING i_pernr        = i_params-pernr
                         i_begda        = i_params-begda
               IMPORTING e_leaving_begda = lv_leave
                         e_accounted_to  = lv_abrdt ).
    IF lv_msg IS NOT INITIAL.
      r_result-success = abap_false.
      r_result-message = lv_msg.
      RETURN.
    ENDIF.

    "3b) Read limits from IT0000/IT0003
    lv_msg = check_limits(
                EXPORTING i_pernr   = i_params-pernr
                          i_begda   = i_params-begda
                          i_leaving_begda = lv_leave
                          i_accounted_to = lv_abrdt ).
    IF lv_msg IS NOT INITIAL.
      r_result-success = abap_false.
      r_result-message = lv_msg.
      RETURN.
    ENDIF.

    "4) Derive BANKL from SUBTY/CBU (or fixed for SUBTY '0'), then validate for SUBTY '2'
    DATA(lv_bankl) = VALUE p0009-bankl( ).
    lv_msg = derive_bankl(
               EXPORTING i_subty = i_params-subty
                         i_cbu   = i_params-cbu
               IMPORTING e_bankl = lv_bankl ).
    IF lv_msg IS NOT INITIAL.
      r_result-success = abap_false.
      r_result-message = lv_msg.
      unlock_emp( i_params-pernr ).
      RETURN.
    ENDIF.

    lv_msg = validate_bankl_bnka(
               EXPORTING i_banks = c_banks
                         i_bankl = lv_bankl
                         i_subty = i_params-subty ).
    IF lv_msg IS NOT INITIAL.
      r_result-success = abap_false.
      r_result-message = lv_msg.
      unlock_emp( i_params-pernr ).
      RETURN.
    ENDIF.

    "5) Derive BKREF/BANKN
    lv_msg = derive_from_cbu(
      EXPORTING i_subty = i_params-subty
                i_cbu   = i_params-cbu
      IMPORTING e_bkref = lv_bkref
                e_bankn = lv_bankn ).
    IF lv_msg IS NOT INITIAL.
      r_result-success = abap_false.
      r_result-message = lv_msg.
      unlock_emp( i_params-pernr ).
      RETURN.
    ENDIF.

    "6) Lock employee
    lv_msg = lock_emp( i_params-pernr ).
    IF lv_msg IS NOT INITIAL.
      r_result-success = abap_false.
      r_result-message = lv_msg.
      RETURN.
    ENDIF.

    "7) Find overlap (same SUBTY)
    ls_old = find_overlap_0009(
               i_pernr = i_params-pernr
               i_begda = i_params-begda
               i_subty = i_params-subty ).

    "8) Delimit if a record is found
    IF 1 = 2. " explicit delimitation skipped; TC=1 will auto-split on INS
      IF ls_old-pernr IS NOT INITIAL.
        lv_msg = delimit_old_0009(
                   i_old       = ls_old
                   i_new_begda = i_params-begda ).
        IF lv_msg IS NOT INITIAL.
          ROLLBACK WORK.
          unlock_emp( i_params-pernr ).
          r_result-success = abap_false.
          r_result-message = lv_msg.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.

    "9) Prepare local copy of params and cap a terminated EE
    DATA ls_params_ins TYPE ty_params.
    ls_params_ins = i_params.
    IF lv_leave IS NOT INITIAL.
      DATA lv_cap_end TYPE endda.
      lv_cap_end = lv_leave - 1.
      IF ls_params_ins-endda > lv_cap_end.
        ls_params_ins-endda = lv_cap_end.
      ENDIF.
      " BEGDA <= ENDDA after capping
      IF ls_params_ins-endda < ls_params_ins-begda.
        ROLLBACK WORK.
        unlock_emp( i_params-pernr ).
        r_result-success = abap_false.
        lv_begda_txt = |{ ls_params_ins-begda DATE = USER }|.
        lv_endda_txt = |{ ls_params_ins-endda DATE = USER }|.
        lv_leave_txt = |{ lv_leave DATE = USER }|.
        r_result-message = |Employee terminated on { lv_leave_txt }, not a valid period for interval { lv_begda_txt }–{ lv_endda_txt }.|.
        RETURN.
      ENDIF.
    ENDIF.

    "10) Insert new 0009
    lv_msg    = insert_new_0009(
                  i_params  = ls_params_ins
                  i_land1   = c_land1
                  i_banks   = c_banks
                  i_bankl   = lv_bankl
                  i_bankn   = lv_bankn
                  i_bkont   = c_bkont
                  i_bkref   = lv_bkref
                  i_zlsch   = c_zlsch
                  i_waers   = c_waers
                  i_abrdt   = lv_abrdt ).

    IF lv_msg IS NOT INITIAL.
      ROLLBACK WORK.
      unlock_emp( i_params-pernr ).
      r_result-success = abap_false.
      r_result-message = lv_msg.
      RETURN.
    ENDIF.

    "11) Commit + unlock
    COMMIT WORK AND WAIT.
    unlock_emp( i_params-pernr ).
    r_result-success = abap_true.
    lv_begda_txt = |{ ls_params_ins-begda DATE = USER }|. "format output message according to the user parameters
    lv_endda_txt = |{ ls_params_ins-endda DATE = USER }|.
    r_result-message = |IT0009 created for { i_params-pernr } ({ lv_begda_txt }–{ lv_endda_txt }).|.
  ENDMETHOD.


  METHOD unlock_emp.
    CALL FUNCTION 'HR_EMPLOYEE_DEQUEUE'
      EXPORTING
        number = i_pernr
      EXCEPTIONS
        OTHERS = 1.
  ENDMETHOD.


  METHOD validate_bankl_bnka.
    CLEAR r_msg.
    "Validate only for subtype '2' (derived from CBU)
    IF i_subty = '2'.
      DATA: ls_addr TYPE bapi1011_address,
            ls_det  TYPE bapi1011_detail,
            ls_ret  TYPE bapiret2.

      CALL FUNCTION 'BAPI_BANK_GETDETAIL'
        EXPORTING
          bankcountry  = i_banks
          bankkey      = i_bankl
        IMPORTING
          bank_address = ls_addr
          bank_detail  = ls_det
          return       = ls_ret.

      IF ls_ret-type CA 'AE'
         OR ls_addr-bank_no IS INITIAL          "not found / unusable
         OR ls_det-bank_delete IS NOT INITIAL.  "marked for deletion
        r_msg = |Bank key { i_bankl } not found for country { i_banks } or it is marked for deletion.| .
        RETURN.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD validate_inputs.
    IF i_params-bankl IS INITIAL.
      r_msg = 'Enter a bank key (BANKL).'.
      RETURN.
    ENDIF.

    IF i_params-begda > i_params-endda.
      r_msg = 'BEGDA must be <= ENDDA'.
      RETURN.
    ENDIF.

    IF strlen( i_params-cbu ) <> c_cbuln.
      r_msg = 'CBU must have exactly 22 digits'.
      RETURN.
    ENDIF.

    DATA(lv_tmp) = i_params-cbu.
    REPLACE ALL OCCURRENCES OF REGEX '[^0-9]' IN lv_tmp WITH ''.
    IF lv_tmp <> i_params-cbu.
      r_msg = 'CBU may contain digits only (0-9)'.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
